//===================================================================================================
//? Importing
//===================================================================================================

//import Enums
import {status } from '../enums/routeEnum';
import {status as busStatus } from '../enums/busEnum';

//import models
import RouteModel from "../models/routeModel";
import BusModel from "../models/busModel";
import RouteStationModel from "../models/routeStationModel";
import stationModel from "../models/stationModel";

import { ConflictError, NotFoundError, ValidationError, InternalError  } from '../errors';

import { UserHelper } from "../helpers/userHelper";
const helper = new UserHelper();

import { normalizeColorToArgbInt } from '../helpers/colorHelper';

import { buildFinalStations, fetchOsrmGeometry } from '../helpers/routeHelper';


//import service
import { StationService } from './stationService';
const stationService = new StationService();
//===================================================================================================



export class RouteService{  


    //===================================================================================================
    //? function to Add Route
    //===================================================================================================

    async addRoute(payload: Record<string, any>): Promise<{ messageKey: string }> {

        const body = payload || {};
        const stations: string[] = Array.isArray(body.stations) ? body.stations : [];

        const startDefaultsResult = await stationService.fetchDefaultStartStations();
        const endDefaultsResult = await stationService.fetchDefaultEndStations();

        const startDefaultIds: string[] = startDefaultsResult.data as string[];
        const endDefaultIds: string[] = endDefaultsResult.data as string[];

        const finalStations = buildFinalStations(stations, startDefaultIds, endDefaultIds);

        const finalPayload: Record<string, any> = {
            ...body,
            totalStops: finalStations.length
        };

        try {
            await helper.add(RouteModel, finalPayload,
                {
                    //-----------------------------------------------------------
                    transform: async (data) => {
                        const out = {...data};
                        if(out.title){
                            out.title  = out.title.toLowerCase().trim();
                        }
                        // remove non-column field
                        delete out.stations;
                        return out;
                    },
                    //-----------------------------------------------------------
                    nonDuplicateFields: ['title'],
                    //-----------------------------------------------------------
                    enumFields: [
                        { field: "status", enumObj: status },
                    ],
                    //-----------------------------------------------------------
                }
            );

            // attach stations to route_stations table if provided
            if(finalStations.length > 0 && finalPayload.title){
                const createdRoute = await RouteModel.findOne({
                    where: { title: String(finalPayload.title).toLowerCase().trim() },
                    attributes: ['id']
                });

                if(createdRoute){
                    const rows = finalStations.map((stationId, idx) => ({
                        routeId: createdRoute.id,
                        stationId,
                        orderIndex: idx
                    }));
                    await RouteStationModel.bulkCreate(rows);
                }
            }

            return { messageKey: 'routes.success.added' };

        } catch (error) {
            console.error('Error occured while creating route.', error);
            if (
                error instanceof ValidationError ||
                error instanceof ConflictError ||
                error instanceof NotFoundError
            ) {
                throw error;
            }
            throw new InternalError('common.errors.internal');
        }
    }

    //===================================================================================================
    //? function to Remove Route
    //===================================================================================================
    async removeRoute(routeId: unknown): Promise<{ messageKey: string }> {
        try {
            await helper.remove(RouteModel, 'id', String(routeId));
            return { messageKey: 'common.crud.removed' };
        
        // ---------------------------------------
        } catch (error) {
            console.error('Error occured while removing route.', error);
            throw error;
        }
    }

    //===================================================================================================
    //? function to Update Route
    //===================================================================================================
    async updateRoute(payload: Record<string, any>): Promise<{ messageKey: string }> {
        try {
            const body = payload || {};
            const { id, title, color, status: routeStatusValue } = body;
            const stations: string[] = Array.isArray(body.stations) ? body.stations : [];

            const startDefaultsResult = await stationService.fetchDefaultStartStations();
            const endDefaultsResult = await stationService.fetchDefaultEndStations();

            const startDefaultIds: string[] = startDefaultsResult.data as string[];
            const endDefaultIds: string[] = endDefaultsResult.data as string[];

            const finalStations = buildFinalStations(stations, startDefaultIds, endDefaultIds);

            if(!id){
                throw new ValidationError('routes.validation.idRequired');
            }

            // validate status (if provided)
            if(routeStatusValue && !Object.values(status).includes(routeStatusValue)){
                throw new ValidationError('common.errors.validation.invalidField');
            }

            const routeExists = await RouteModel.findOne({
                where: { id },
                attributes: ['id']
            });

            if(!routeExists){
                throw new NotFoundError('common.errors.notFound');
            }

            // normalize title
            const normalizedTitle = title ? String(title).toLowerCase().trim() : undefined;

            // build updates
            const updates: Record<string, any> = {};
            if(normalizedTitle !== undefined) updates.title = normalizedTitle;
            if(color !== undefined) updates.color = color;
            if(routeStatusValue !== undefined) updates.status = routeStatusValue;
            updates.totalStops = finalStations.length;

            const [updatedCount] = await RouteModel.update(updates, {
                where: { id }
            });

            if(updatedCount === 0){
                throw new ConflictError('common.crud.notUpdated');
            }

            // replace stations list
            await RouteStationModel.destroy({
                where: { routeId: id }
            });

            if(finalStations.length > 0){
                const rows = finalStations.map((stationId, idx) => ({
                    routeId: id,
                    stationId,
                    orderIndex: idx
                }));
                await RouteStationModel.bulkCreate(rows);
            }

            return { messageKey: 'routes.success.updated' };

        // ---------------------------------------
        } catch (error) {
            console.error('Error occured while updating route.', error);
            throw error;
        }
    }


    
    //===================================================================================================
    //? function to view All routes for operating buses or only Operating(working) routes 
    //===================================================================================================
    async viewRoutes(displayAll: boolean): Promise<{ messageKey: string; data: unknown }> {
        try{

            let routes: any[] = [];

            if(displayAll){
                routes = await RouteModel.findAll({
                    attributes: ['id', 'title', 'color', 'totalStops', 'status']
                });

                for (const route of routes) {
                    (route as any).dataValues.colorInt = normalizeColorToArgbInt((route as any)?.color);
                }
                // attach stations per route
                for (const route of routes) {
                    const routeStations = await RouteStationModel.findAll({
                        where: { routeId: route.id },
                        attributes: ['stationId', 'orderIndex'],
                        order: [['orderIndex', 'ASC']]
                    });

                    const stationIds: string[] = routeStations.map((rs: any) => rs.stationId);
                    let stations: { id: string; stationName: string; latitude: number; longitude: number }[] = [];
                    if (stationIds.length > 0) {
                        const stationRows = await stationModel.findAll({
                            where: { id: stationIds },
                            attributes: ['id', 'stationName', 'latitude', 'longitude']
                        });
                        const stationMap = new Map(
                            stationRows.map((st: any) => [st.id, {
                                stationName: st.stationName,
                                latitude: st.latitude,
                                longitude: st.longitude
                            }])
                        );
                        stations = routeStations.map((rs: any) => ({
                            id: rs.stationId,
                            stationName: stationMap.get(rs.stationId)?.stationName || '',
                            latitude: Number(stationMap.get(rs.stationId)?.latitude ?? 0),
                            longitude: Number(stationMap.get(rs.stationId)?.longitude ?? 0)
                        }));
                    }

                    (route as any).dataValues.stations = stations;
                }
                
            }else{
                const routeId = await BusModel.findAll({
                    where: {
                        status: busStatus.operating
                    },
                    attributes: ['assignedRoute']
                })

                for(let i = 0; i< routeId.length; i++){
                    const assignedRouteId = routeId[i]?.assignedRoute;
                    if (!assignedRouteId) {
                        continue;
                    }
                    let route = await RouteModel.findOne({
                        where: {
                            id: assignedRouteId
                        },
                        attributes: ['id', 'title', 'color', 'totalStops', 'status']
                    });
                    if(route) {
                        (route as any).dataValues.colorInt = normalizeColorToArgbInt((route as any)?.color);
                        routes.push(route);
                    }
                }
            }

            return { messageKey: 'common.crud.fetched', data: routes };

        // ---------------------------------------
        }catch(error){
            console.error('Error occured while viewing routes.', error);
            throw new InternalError('common.errors.internal');
        }
    }


    //===================================================================================================
    //? function to Fetch All Routes for Map View (station coordinates)
    //===================================================================================================
    async fetchRoutesMap(): Promise<{ messageKey: string; data: unknown }> {
        try {

            type StationRow = {
                id: string;
                stationName: string;
                latitude: number;
                longitude: number;
            };

            type RouteStationRow = {
                stationId: string;
                orderIndex: number;
            };

            type RoutePoint = {
                stationId: string;
                stationName: string;
                latitude: number;
                longitude: number;
                orderIndex: number;
            };

            const routes = await RouteModel.findAll({
                attributes: ['id', 'title', 'color', 'totalStops', 'status']
            });

            for (const route of routes) {
                (route as any).dataValues.colorInt = normalizeColorToArgbInt((route as any)?.color);
            }

            // attach ordered points per route -------------------------------------------------
            for (const route of routes) {
                const routeStations = await RouteStationModel.findAll({
                    where: { routeId: route.id },
                    attributes: ['stationId', 'orderIndex'],
                    order: [['orderIndex', 'ASC']]
                });

                // get route stations with their order index ------------------------------------------
                const routeStationsTyped: RouteStationRow[] = routeStations.map((rs) => ({
                    stationId: String((rs as unknown as { stationId: unknown }).stationId),
                    orderIndex: Number((rs as unknown as { orderIndex: unknown }).orderIndex ?? 0),
                }));

                // get route stations ids ordered by orderIndex ------------------------------------------
                const stationIdsFromDb: string[] = routeStationsTyped
                    .map((routeStation) => routeStation.stationId)
                    .map((id) => String(id));

                // if default start/end stations are missing, enforce them-------------------------------
                const startDefaultsResult = await stationService.fetchDefaultStartStations();
                const endDefaultsResult = await stationService.fetchDefaultEndStations();

                const startDefaultIds: string[] = startDefaultsResult.data as string[];
                const endDefaultIds: string[] = endDefaultsResult.data as string[];

                const requiredDefaultIds = Array.from(new Set([
                    ...(Array.isArray(startDefaultIds) ? startDefaultIds : []),
                    ...(Array.isArray(endDefaultIds) ? endDefaultIds : []),
                ]));

                const hasAllRequiredDefaults = requiredDefaultIds.every((id) => stationIdsFromDb.includes(id));

                const stationIdsOrdered: string[] = hasAllRequiredDefaults
                    ? stationIdsFromDb
                    : buildFinalStations(stationIdsFromDb, startDefaultIds, endDefaultIds);

                // -------------------------------------------------------------------

                // use unique ids only for DB fetch, but keep ordered list for points
                const stationIdsFetch: string[] = Array.from(new Set(stationIdsOrdered));

                if (stationIdsFetch.length === 0) {
                    (route as any).dataValues.points = [];
                    continue;
                }

                // get stations data from db ---------------------
                const stationRows = await stationModel.findAll({
                    where: { id: stationIdsFetch },
                    attributes: ['id', 'stationName', 'latitude', 'longitude']
                });

                const stationRowsTyped: StationRow[] = stationRows.map((st) => ({
                    id: String((st as unknown as { id: unknown }).id),
                    stationName: String((st as unknown as { stationName: unknown }).stationName ?? ''),
                    latitude: Number((st as unknown as { latitude: unknown }).latitude ?? 0),
                    longitude: Number((st as unknown as { longitude: unknown }).longitude ?? 0),
                }));

                const stationMap = new Map<string, StationRow>(
                    stationRowsTyped.map((st) => [st.id, st])
                );
                //--------------------------------------------------

                const orderIndexMap = new Map<string, number>(
                    routeStationsTyped.map((rs) => [rs.stationId, rs.orderIndex])
                );

                // create points array from ordered stations "stationIdsOrdered" -------------------------
                const points: RoutePoint[] = [];

                const pointCoords: Array<{ latitude: number; longitude: number }> = [];

                // loop through ordered stations and ensure they are found wiht valid coordinates
                for (const stationId of stationIdsOrdered) {
                    const station = stationMap.get(stationId);
                    // skip if station not found 
                    if (!station) {
                        continue;
                    }
                    // skip if station has invalid coordinates
                    if (station.latitude === 0 || station.longitude === 0) {
                        continue;
                    }
                    // else push to points
                    points.push({
                        stationId,
                        stationName: station.stationName,
                        latitude: station.latitude,
                        longitude: station.longitude,
                        orderIndex: Number(orderIndexMap.get(stationId) ?? 0)
                    });

                    pointCoords.push({ latitude: station.latitude, longitude: station.longitude });
                }

                // get road-following polyline geometry ---------------------------------------------
                const routedGeometry = await fetchOsrmGeometry(pointCoords);
                (route as any).dataValues.geometry = routedGeometry ?? pointCoords;

                (route as any).dataValues.points = points;
            }

            return { messageKey: 'common.crud.fetched', data: routes };

        // ---------------------------------------
        } catch (error) {
            console.error('Error occured while fetching routes map data.', error);
            throw new InternalError('common.errors.internal');
        }
    }

}

